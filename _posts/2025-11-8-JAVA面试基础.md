###### Java 和 C++ 的区别?

- 我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：Java 不提供指针来直接访问内存，程序内存更加安全Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。
------

这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean 。
 ##### 基本类型和包装类型的区别？
 
 - 用途：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。
 - 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
 - 占用空间：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。比较方式：对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法
------

##### 包装类型的缓存机制

- 当我们使用包装类的静态方法（如 Integer.valueOf()）创建对象时，JVM 不总是新建对象，而是复用常见值范围内的缓存对象。
也就是说：

`Integer a = Integer.valueOf(100);
Integer b = Integer.valueOf(100);
System.out.println(a == b); // true，因为复用了缓存对象
`

而如果超出缓存范围：

```Integer a = Integer.valueOf(200);
Integer b = Integer.valueOf(200);
System.out.println(a == b); // false，```
```

###### 什么是JAVA中的自动装箱、拆箱
- 基础类用包装类互相替换
```
Integer i = 10;  //装箱
int n = i;   //拆箱

Integer i = 10 等价于 Integer i = Integer.valueOf(10)
int n = i 等价于 int n = i.intValue();
```
##### 为什么会出现浮点数精度缺失

- 计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失

- 解决方法：使用BigDecimal表示大数，equal:比较数值和精度，compareTo，只比较数值

- 超过long整型用BigInteger,其底层是一个数组

##### 成员变量与局部变量
- 语法形式：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。

- 存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。、
- 生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。

- 默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

*** 静态变量static的作用
